pragma solidity >=0.6.0 <0.8.0;
import "@openzeppelin/contracts/math/SafeMath.sol";
import "@openzeppelin/contracts/utils/Address.sol";
import "@openzeppelin/contracts/utils/EnumerableSet.sol";
import "@openzeppelin/contracts/utils/EnumerableMap.sol";
import "@openzeppelin/contracts/utils/Strings.sol";

contract NFTcryptTools {
  using SafeMath for uint256;
  using Address for address;
  using EnumerableSet for EnumerableSet.UintSet;
  using EnumerableMap for EnumerableMap.UintToAddressMap;
  using Strings for uint256;

  mapping (uint256 => string) public _secretHash;
  mapping (uint256 => string) public _encrSecret;
  mapping (uint256 => uint256) public origPrice;
  mapping (uint256 => bool) public forSale;
  //mapping (uint256 => uint256) public batchReg;
  mapping (uint256 => EnumerableSet.UintSet) _batchSet;
  mapping (uint256 => uint256) public batchMax;
  uint256 maxIndex = 0;
  uint256 lastBatch = 0;

//  string public ownerName;
/*
  function batchExists(uint256 batchId) public view returns (bool) {
    if (lastBatch>=batchId) {
      return true;
    } else {
      return false;
    }
  }*/
  event LogPriceSet(uint256 tokenId,uint256 price);
  event LogNewHash(uint256 batchId, string  hashed);
  event LogNewSecret(uint256 tokenId, string  secret);

  function batchSize(uint256 batchId) public view returns (uint256)  {
    require(lastBatch>=batchId, "no b");
    return batchMax[batchId];
  }

  /*function getBatch(uint256 tokenId) public view returns (uint256) {
    return batchReg[tokenId];

  }

  function getOwnerName() public view returns (string memory) {
    return ownerName;
  }*/

  function _setSecretHash(uint256 batchId, string memory hashed) internal  {
   _secretHash[batchId] = hashed;
   emit LogNewHash( batchId,   hashed);
 }
 function viewSecretHash(uint256 batchId) public view returns (string memory) {
   return _secretHash[batchId];
 }
 function _setEncSecret(uint256 tokenId, string memory secret) internal {
   _encrSecret[tokenId] = secret;
   emit LogNewSecret( tokenId,   secret);
 }
 function viewEncSecret(uint256 tokenId) public view returns (string memory) {
   return _encrSecret[tokenId];
 }

 function getPrice(uint256 tokenId) public view returns(uint256) {
   require(forSale[tokenId]==true);
   return  origPrice[tokenId];
 }
 /*
 function checkForSale(uint256 tokenId) public view returns (bool) {
   if (forSale[tokenId]==true) {
     return true;
   } else {
     return false;}
 } */
 function _setPrice(uint256 tokenId, uint256 price) internal {
   origPrice[tokenId]=price;
   forSale[tokenId]=true;
   emit LogPriceSet(tokenId,price);
 }
}
